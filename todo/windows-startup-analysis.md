# Анализ: запуск sing-box под Windows (первая попытка часто не срабатывает)

## Как сейчас запускается sing-box под Windows

1. **Общая ветка** (не macOS с TUN): `exec.Command(singboxPath, "run", "-c", filepath.Base(configPath))`, `Dir = bin/`, stdout/stderr в `ChildLogFile`, `platform.PrepareCommand` (Windows: `CREATE_NO_WINDOW` + скрытое окно).
2. **Запуск**: `ac.SingboxCmd.Start()`. При ошибке — `ShowStartupError()` и выход. При успехе — ставится «running», в горутине вызывается `Monitor(cmd)` (ждёт `cmd.Wait()`).
3. **При падении процесса**: `Monitor` считает краш, ждёт 2 секунды и вызывает `Start(true)` (автоперезапуск).

Принудительного удаления TUN (netsh) перед Start или при выходе **нет** — решено положиться на то, что Windows сама закрывает интерфейсы.

---

## Что пробовали и что не сработало

### 1. Удаление TUN через netsh перед каждым Start
- **Идея:** читать из конфига имя TUN (`GetTunInterfaceName`), проверять через `netsh interface show interface name=...`, при наличии вызывать `netsh interface delete interface name=...`.
- **Результат:** в логах при крашах интерфейс в netsh не отображался (`Interface 'singbox-tun0' does not exist`), но sing-box всё равно падал с «Cannot create a file when that file already exists» / «open interface take too much time». То есть имя/ресурс держит драйвер Wintun, а не видимый в netsh адаптер.
- **Решение:** логику удаления перед Start убрали.

### 2. Удаление TUN при выходе (в Monitor)
- **Идея:** при любом выходе sing-box (Stop, нормальный exit, краш) вызывать `removeTunInterfaceIfWindows(configPath)` — прочитать имя TUN из конфига и выполнить netsh delete.
- **Результат:** не дало стабильного улучшения; пользователь отметил, что «винда тоже нормально закрывает интерфейсы» и что это были неверные попытки починить то, что не так.
- **Решение:** вызовы `removeTunInterfaceIfWindows` в Monitor и сами функции (`removeTunInterfaceIfWindows`, `removeTunInterface`, `checkTunInterfaceExists`) удалены.

### 3. Задержки между Stop и Start
- **Пробовали:** задержка 2 с перед Start при «холодном» старте; 3 с если Stop был недавно; пауза после удаления TUN.
- **По логам (releases/run/logs):** при паузе **~1 с** после Stop — краш; при **~3 с** — краш; при **4–12 с** — бывали и успех, и краш (при 6–7 с тоже случались падения). Порог ненадёжный.
- **Решение:** задержки перед Start убраны.

### 4. Парсинг конфига (trailing commas)
- **Проблема:** при конфиге с trailing commas парсинг падал (`invalid character ']'`), лаунчер не получал имя TUN — это мешало только когда ещё использовали удаление TUN по имени.
- **Решение:** в `getConfigJSON()` добавлена очистка trailing commas (до и после jsonc); этой функцией пользуются `GetSelectorGroupsFromConfig`, `GetTunInterfaceName`, `ConfigHasTun`. Оставили как улучшение парсинга, не как «фикс TUN».

### 5. Идея с config-empty.json при выходе
- **Идея:** при выходе sing-box на Windows запускать его с минимальным конфигом (TUN + один rule_set с заведомо несуществующим URL), чтобы процесс штатно упал при загрузке правил и освободил TUN.
- **Статус:** не доводили до стабильного деплоя; ветку с этой логикой откатили.

---

## Что ещё можно попробовать

- **Увеличить задержку автоперезапуска только для Windows** (сейчас 2 с) — после краша дать 4–5 с перед следующим Start. По логам после краша 2 с обычно хватает; после **user Stop** пауза не гарантирует успех.
- **Задержка перед Start, если недавно был Stop:** например 5–10 с, только на Windows. Порог по логам ненадёжный (иногда падает и при 6–7 с), но можно попробовать как опцию в настройках.
- **Вернуть идею config-empty при выходе:** при Stop/exit/crash на Windows запускать sing-box с конфигом, который падает на загрузке rule_set; дождаться выхода процесса. Теоретически может помочь «штатно» освободить TUN перед следующим Start.
- **Обновить Wintun:** проверить актуальную версию wintun.dll и драйвера, при необходимости обновить.
- **Антивирус и исключения:** убедиться, что папка с sing-box и wintun не под сканом в реальном времени; при необходимости добавить исключения.
- **Документация / UI:** подсказка после Stop: «Подождите несколько секунд перед повторным запуском» (только для Windows или общая).

---

## Предположения (гипотезы)

### 1. TUN / Wintun не успевают освободиться
- После завершения процесса Windows/драйвер может не сразу освободить имя или ресурс; при быстром повторном Start sing-box получает «file already exists».
- Задержки и принудительный netsh delete не дали стабильного эффекта; решено не полагаться на них.

### 2. «Холодный» старт Wintun после перезагрузки
- При первом обращении к Wintun драйвер поднимается; возможен сбой при первом создании адаптера.
- **TODO:** при воспроизведении — логи sing-box после перезагрузки; при необходимости задержка или повторная попытка только для первого старта.

### 3. Ошибка при создании процесса (Start() возвращает err)
- Не найден wintun.dll, блокировка антивирусом и т.п. Показывается диалог, автоперезапуск не вызывается.
- **TODO:** в документации/UI подсказать проверять антивирус и наличие wintun.dll.

### 4. Автозапуск с `-start`: слишком рано
- Задержка 1 с после старта приложения может быть мала: сеть/драйверы ещё не готовы.
- **TODO:** рассмотреть увеличение `autoStartDelay` для Windows (например, 3–5 с) или опцию в настройках.

---

## Что проверить по логам (без правок)

- **sing-box.log:** при неудачной попытке — `configure tun interface: Cannot create a file when that file already exists`, `open interface take too much time`.
- **singbox-launcher.log:** момент Stop, момент следующего Start, задержка между ними; успех или краш после перезапуска.

---

## Ссылки на код

- Запуск: `core/process_service.go` — `Start()`, `exec.Command`, `Monitor`.
- Конфиг (TUN, селекторы): `core/config/config_loader.go` — `getConfigJSON()`, `GetTunInterfaceName`, `ConfigHasTun`, `GetSelectorGroupsFromConfig`.
- Windows: `internal/platform/platform_windows.go` — `PrepareCommand`, `GetProcessNameForCheck`.
- Автозапуск: `main.go` — `autoStartDelay`, `-start` и вызов `core.StartSingBoxProcess()`.
