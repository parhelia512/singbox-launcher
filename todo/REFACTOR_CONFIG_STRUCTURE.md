# TODO: Рефакторинг структуры пакетов конфигурации

## Описание задачи

Провести рефакторинг структуры пакетов для работы с конфигурацией и подписками с целью улучшения организации кода, разделения ответственности и упрощения навигации.

## Проблемы текущей структуры

1. **Смешанная ответственность**: `subscription_parser.go` содержит и типы, и функции, и константы
2. **Путаница в именах**: `parsers/subscription_parser.go` и `core/subscription_parser.go` 
3. **Избыточное разделение**: `config_service.go` и `config_service_impl.go` (62 строки vs 1020 строк)
4. **Нет логической группировки**: функции разбросаны без чёткой структуры

## Цель

Создать логичную структуру:
- `core/config/models.go` - модели данных конфигурации
- `core/config/` - всё про config.json (парсинг, миграции, генерация)
- `core/config/subscription/` - всё про подписки (загрузка, декодирование, парсинг узлов)
- Удалить избыточные файлы

## Итоговая структура

```
core/
├── config/                        # ← ПЕРЕИМЕНОВАТЬ parsers/ → config/
│   ├── models.go                  # ← НОВЫЙ (модели конфигурации)
│   │   - ParserConfig, ProxySource, OutboundConfig, WizardConfig
│   │   - ParserConfigVersion, SubscriptionUserAgent
│   │   - Методы: IsWizardHidden(), GetWizardRequired()
│   │
│   ├── config_loader.go           # ← НОВЫЙ (чтение разных частей config.json)
│   │   - GetSelectorGroupsFromConfig()  (из core/config_parser.go)
│   │   - GetTunInterfaceName()          (объединить дубликаты из controller.go и process_service.go)
│   │   - Общие утилиты: readConfigFile(), cleanJSONC()
│   │
│   ├── parser/                    # ← НОВЫЙ подпакет: работа с @ParserConfig блоком
│   │   ├── factory.go             # ← НОВЫЙ (фабрика ParserConfig)
│   │   │   - ExtractParserConfig()
│   │   │   - NormalizeParserConfig()
│   │   │   - LogDuplicateTagStatistics()
│   │   │
│   │   ├── migrator.go            # ← ПЕРЕНЕСТИ из core/config_migrator.go
│   │   │   - Миграция версий @ParserConfig
│   │   │
│   │   └── block_extractor.go     # ← ПЕРЕИМЕНОВАТЬ parsers/subscription_parser.go
│   │       - ExtractParserConfigBlock()
│   │
│   ├── updater.go                 # ← НОВЫЙ
│   │   - UpdateConfigFromSubscriptions()
│   │   - writeToConfig()
│   │
│   ├── generator.go               # ← НОВЫЙ
│   │   - GenerateNodeJSON()
│   │   - GenerateSelector()
│   │   - GenerateOutboundsFromParserConfig()
│   │   - OutboundGenerationResult (тип)
│   │   - filterNodesForSelector() и helper функции
│   │
│   └── subscription/              # ← НОВЫЙ подпакет
│       ├── source_loader.go       # ← НОВЫЙ
│       │   - LoadNodesFromSource()  (из ProcessProxySource)
│       │   - applyTagPrefixPostfix()
│       │   - replaceTagVariables()
│       │   - MakeTagUnique()
│       │   - IsSubscriptionURL()
│       │   - MaxNodesPerSubscription (константа)
│       │
│       ├── node_parser.go         # ← ПЕРЕНЕСТИ из parsers/node_parser.go
│       │   - ParseNode()
│       │   - IsDirectLink()
│       │
│       ├── decoder.go             # ← НОВЫЙ (из parsers/subscription_parser.go)
│       │   - DecodeSubscriptionContent()
│       │
│       └── fetcher.go             # ← НОВЫЙ (из core/subscription_parser.go)
│           - FetchSubscription()
│
├── config_service.go              # ← ОБЪЕДИНИТЬ с config_service_impl.go
│   - ConfigService struct
│   - NewConfigService()
│   - RunParserProcess()
│
└── config_parser.go               # ← УДАЛИТЬ (содержимое переедет в config/config_loader.go)
```

## Детальное распределение

### Шаг 1: Создать `core/config/models.go`

**Содержимое:**
- Константы версионирования и идентификации клиента
- Все основные типы данных для конфигурации парсера, источников прокси, конфигурации исходящих соединений и настроек мастера
- Методы типов для проверки видимости и обязательности элементов в мастере настройки

**Источник:** Все типы и константы из `core/subscription_parser.go`

**Важно:** Модели находятся в пакете `config`, так как они относятся к конфигурации парсера. Другие модули в `config/` будут использовать эти типы из того же пакета.

---

### Шаг 2: Переименовать `parsers/` → `config/`

**Действия:**
- Переименовать директорию для лучшей семантики названия
- Обновить package declaration во всех файлах
- Обновить все импорты в проекте на новое имя пакета
- Переместить все тесты в новую директорию

---

### Шаг 3: Создать `core/config/subscription/`

**Создать подпакет `config/subscription/`**

#### 3.1: `config/subscription/decoder.go`

**Ответственность:** Декодирование контента подписки
- Функция декодирования контента подписки (определение кодировки и декодирование)
- Вспомогательная функция для попыток декодирования Base64

**Источник:** Логика декодирования из `parsers/subscription_parser.go`

#### 3.2: `config/subscription/fetcher.go`

**Ответственность:** Загрузка подписок по сети
- Функция получения контента подписки по URL с обработкой ошибок и таймаутов

**Источник:** Логика загрузки подписок из `core/subscription_parser.go`

**Зависимости:** Использует декодер для обработки полученного контента и утилиты из core для HTTP клиента

#### 3.3: `config/subscription/node_parser.go`

**Ответственность:** Парсинг строк узлов прокси
- Функция парсинга URI узла прокси в структурированный объект
- Функция определения типа ссылки (прямая или подписка)

**Источник:** Весь файл `parsers/node_parser.go` переносится без изменений логики

#### 3.4: `config/subscription/source_loader.go` (НОВЫЙ)

**Ответственность:** Загрузка и обработка узлов из источника прокси

**Основная функция:**
- Загружает узлы из ProxySource (подписка или прямая ссылка)
- Обрабатывает все типы источников (URL подписки, legacy прямые ссылки, connections)
- Применяет преобразования тегов и делает их уникальными
- Поддерживает callback для отслеживания прогресса

**Логика работы:**
1. Определение типа источника (подписка через URL или прямая ссылка)
2. Загрузка контента через соответствующий механизм
3. Парсинг каждой строки в узел через парсер узлов
4. Применение правил тегов (prefix, postfix, маски, переменные)
5. Уникализация тегов для избежания конфликтов

**Утилиты:**
- Применение префикса, постфикса и маски к тегам
- Замена переменных в шаблонах тегов (поддержка динамических значений)
- Уникализация тегов с ведением статистики
- Проверка типа источника (URL подписки или прямая ссылка) - должна быть экспортирована для UI

**Источник:** Вся логика обработки источников из `core/config_service_impl.go`, включая утилиты для работы с тегами

---

### Шаг 5: Создать `core/config/config_loader.go`

**Ответственность:** Чтение различных частей config.json для разных целей (не парсинг структуры ParserConfig)

**Основные функции:**
- Извлечение селектор-групп из конфига (для UI)
- Получение имени TUN интерфейса из конфига (для процесса)
- Общие утилиты для чтения и очистки JSONC

**Функции:**
- `GetSelectorGroupsFromConfig(configPath)` - извлекает список селектор-групп из outbounds и route
- `GetTunInterfaceName(configPath)` - извлекает имя TUN интерфейса из inbounds
- Вспомогательные функции для чтения файла и очистки JSONC (если нужны общие утилиты)

**Источник:**
- `GetSelectorGroupsFromConfig()` из `core/config_parser.go`
- `getTunInterfaceName()` из `core/controller.go` и `core/process_service.go` (объединить дубликаты)

**Примечание:** 
- Это простые функции чтения конфига, не связанные с парсингом структуры ParserConfig
- `LoadClashAPIConfig()` остается в `api/clash.go` (разные цели, другой уровень абстракции)

---

### Шаг 6: Создать подпакет `core/config/parser/`

**Создать подпакет `config/parser/` для работы с @ParserConfig блоком**

#### 6.1: `config/parser/block_extractor.go`

**Ответственность:** Чистое извлечение блока из файла (Pure parsing)
- Только поиск и извлечение JSON строки из комментария @ParserConfig
- Не зависит от типов models, не знает про версии
- Возвращает: JSON строка (string)
- Вход: массив байтов файла

**Границы:** Не парсит JSON, не знает про структуру, только текстовая обработка

**Источник:** Логика извлечения блока из `parsers/subscription_parser.go`

#### 6.2: `config/parser/migrator.go`

**Ответственность:** Преобразование между версиями формата @ParserConfig
- Извлечение версии из JSON строки
- Миграция структуры между версиями (v1→v2→v3→v4)
- Вход: JSON строка (string) + текущая версия
- Выход: распарсенный объект ParserConfig (уже мигрированный)

**Границы:** 
- Не читает файлы, не нормализует дефолты
- Работает только с преобразованием формата
- После миграции возвращает объект актуальной версии

**Источник:** Перенести из `core/config_migrator.go`

**Зависимости:** Использует типы из `config/models` (того же пакета) для работы с конфигурацией

#### 6.3: `config/parser/factory.go`

**Ответственность:** Фабрика для создания объекта ParserConfig (парсинг и загрузка существующей конфигурации)

**Порядок операций (строго последовательно):**

1. **Extract** → вызывает `parser/block_extractor.ExtractParserConfigBlock()`
   - Читает файл config.json
   - Извлекает JSON строку из комментария

2. **ExtractVersion** → вызывает `parser/migrator.ExtractVersion()`
   - Определяет версию из JSON строки

3. **Parse** → `json.Unmarshal()` в промежуточную структуру
   - Парсит JSON строку в объект
   - Если версия уже актуальная - парсит напрямую в ParserConfig

4. **Migrate** → вызывает `parser/migrator.MigrateRaw()` (если версия не актуальная)
   - Преобразует структуру к актуальной версии
   - Возвращает объект актуальной версии

5. **Normalize** → вызывает `NormalizeParserConfig(parserConfig, false)`
   - Устанавливает версию в актуальную (если не установлена)
   - Устанавливает дефолтные значения (reload = "4h")
   - Валидирует структуру
   - **НЕ обновляет last_updated** (это ЗАГРУЗКА существующего конфига, не создание нового)

6. **Return** → возвращает готовый объект ParserConfig для работы

**Функции:**
- `ExtractParserConfig(configPath)` - главная функция координации (читает существующий конфиг)
- `NormalizeParserConfig(parserConfig, updateLastUpdated)` - нормализация дефолтов (может быть вызвана отдельно)
- `LogDuplicateTagStatistics()` - утилита для логирования

**Важно:** 
- Это ЗАГРУЗКА существующего конфига из файла, поэтому `NormalizeParserConfig` вызывается с `updateLastUpdated=false`
- `last_updated` обновляется только когда мы создаем/обновляем конфиг в процессе обработки подписок (см. updater.go)
- Normalize вызывается сразу после миграции для гарантии работы с нормализованными данными

**Источник:**
- Логика координации из `core/subscription_parser.go` (ExtractParserConfig)
- Логика нормализации из `core/subscription_parser.go` (NormalizeParserConfig)
- Логика статистики из `core/config_service_impl.go` (LogDuplicateTagStatistics)

**Зависимости:**
- Использует `parser/block_extractor` для извлечения
- Использует `parser/migrator` для миграции
- Использует типы из `config/models` (того же пакета)

---

**Примечание о writeToConfig:**

`writeToConfig` получает уже обновленный `last_updated` из updater и записывает конфиг. Дефолты уже нормализованы при загрузке через `parser.ExtractParserConfig()` (пакет `config/parser`, файл `factory.go`).

---

### Шаг 8: Создать `core/config/generator.go`

**Ответственность:** Генерация JSON для узлов и селекторов

**Тип результата:** Структура с результатами генерации (JSON строки, количество узлов, селекторов)

**Основные функции:**
- Генерация JSON строки для отдельного узла прокси
- Генерация JSON строки для селектора с фильтрацией узлов
- Генерация всех outbounds из конфигурации парсера с поддержкой прогресса

**Вспомогательные функции:**
- Фильтрация узлов по критериям селектора
- Преобразование фильтров в удобный формат
- Сопоставление узлов с критериями фильтрации
- Извлечение значений из узла по ключам
- Проверка соответствия паттернам

**Источник:** Вся логика генерации JSON из `core/config_service_impl.go`

**Зависимости:**
- Использует типы узлов из subscription пакета
- Использует типы конфигурации из `config/models` (того же пакета)

---

### Шаг 9: Создать `core/config/updater.go`

**Ответственность:** Обновление config.json из подписок

**Основные функции:**
- Координация процесса обновления конфигурации из всех источников подписок
- Запись сгенерированного контента в config.json между маркерами

**Логика работы:**
1. Загрузка текущей конфигурации (через `parser.ExtractParserConfig()` из пакета `config/parser`)
2. Обход всех источников подписок
3. Загрузка и обработка узлов из каждого источника
4. Генерация JSON для узлов и селекторов
5. **Обновление `last_updated` timestamp** (в этот момент создан новый конфиг после обработки подписок)
6. Запись обновленного конфига в файл config.json

**Важно:** 
- `last_updated` обновляется именно здесь, когда готов новый конфиг после успешной обработки всех подписок
- Это момент создания/обновления конфига, а не просто чтения существующего

**Адаптация:** Функция обновления должна быть преобразована из метода сервиса в самостоятельную функцию, принимающую необходимые параметры напрямую

**Источник:** Вся логика обновления конфигурации из `core/config_service_impl.go`

**Зависимости:**
- Использует пакет `config/parser` (файл `factory.go`) для загрузки конфигурации
- Использует generator для создания JSON
- Использует типы из `config/models` (того же пакета)

---

### Шаг 10: Обновить `core/config_service.go`

**Ответственность:** Тонкий слой сервиса для интеграции с UI

**Содержимое:**
- Структура сервиса конфигурации
- Конструктор сервиса
- Метод запуска процесса парсинга для UI

**Изменения:**
- Объединить минимальную логику из `config_service_impl.go` (только структуру сервиса и его методы)
- Убрать всю бизнес-логику в соответствующие модули config пакета
- Метод запуска процесса должен делегировать работу в функции из config пакета

---

### Шаг 11: Обновить все импорты

**Особое внимание:**
- `GetSelectorGroupsFromConfig()` теперь в `config/config_loader`
- `getTunInterfaceName()` теперь в `config/config_loader` (объединенная версия)
- `ExtractParserConfig()` теперь в пакете `config/parser` (файл `factory.go`)
- Обновить все места использования в `controller.go` и `process_service.go`

**Области обновления:**

1. **В `core/` пакете:**
   - Сервис конфигурации должен импортировать новые пакеты `config/parser` и `config/subscription`
   - Контроллеры должны использовать обновлённые пути импортов
   - Все ссылки на старый пакет `parsers` должны быть заменены на `config/parser` или `config/subscription`

2. **В `ui/` пакете:**
   - Типы остаются доступны через `core.*` (обратная совместимость)
   - Функции утилиты (например, проверка типа URL) должны импортироваться из нового расположения

3. **В `core/` пакете (controller.go, process_service.go):**
   - Заменить `GetSelectorGroupsFromConfig` на импорт из `config/config_loader`
   - Заменить `getTunInterfaceName` на импорт из `config/config_loader`
   - Удалить дубликат функции `getTunInterfaceName` из `controller.go` (оставить только использование)

4. **Тесты:**
   - Все тесты должны быть обновлены с новыми путями импортов
   - Тесты должны быть перемещены в соответствующие директории новой структуры

---

### Шаг 12: Удалить устаревшие файлы

**Файлы к удалению:**
- `core/config_service_impl.go` (после объединения с config_service.go)
- `core/subscription_parser.go` (всё содержимое распределено)
- `core/config_migrator.go` (перенесён в config/parser/migrator.go)
- `core/config_parser.go` (содержимое перенесено в config/config_loader.go)
- `core/parsers/` (переименована в config/ и реорганизована)

**Дополнительно:**
- Удалить дубликат `getTunInterfaceName()` из `controller.go` (оставить только использование)

---

## Обновление тестов

**Действия:**
- Переименовать тесты согласно новой структуре файлов
- Переместить тесты в соответствующие директории новой структуры
- Обновить все импорты на новые пути пакетов
- Адаптировать вызовы функций под новую архитектуру (убрать ресиверы где необходимо, обновить сигнатуры)

---

## Проверка после рефакторинга

**Этапы проверки:**
1. Успешная компиляция всего проекта
2. Запуск всех тестов во всех затронутых пакетах
3. Статический анализ кода (go vet)
4. Проверка корректности импортов

**Функциональная проверка:**
- Извлечение блока конфигурации работает корректно
- Загрузка подписок выполняется без ошибок
- Парсинг узлов обрабатывает все типы ссылок
- Генерация JSON создаёт валидный вывод
- Обновление config.json сохраняет формат файла
- UI компоненты используют обновлённый API
- Все существующие тесты проходят успешно

---

## Риски и ограничения

1. **Циклические зависимости**: 
   - `config/subscription` импортирует `core` (для network_utils) - это нормально
   - Модули в `config/` используют типы из `config/models` (того же пакета) - это нормально
   - Проверить, что нет `config` → `core` → `config` циклов

2. **Публичный API**: 
   - Типы из `config/models` должны быть доступны через `core/config` для обратной совместимости
   - `IsSubscriptionURL` должен быть экспортирован для UI

3. **Тесты**: 
   - Все тесты нужно обновить для новых импортов
   - Убедиться, что все функции доступны для тестирования

---

## Зависимости между модулями

**Иерархия зависимостей:**
- `core/config/` - пакет для работы с config.json
  - `models.go` - базовые типы конфигурации (ParserConfig, ProxySource, OutboundConfig, WizardConfig)
  - `config_loader` - независимый, читает config.json для разных целей (селекторы, TUN)
  - `parser/` - подпакет для работы с @ParserConfig блоком
    - `block_extractor` - независимый, извлекает блок из файла
    - `migrator` - зависит от models (того же пакета)
    - `factory.go` - зависит от block_extractor, migrator и models (того же пакета)
  - `updater` зависит от пакета `config/parser`, generator и models (того же пакета)
  - `generator` зависит от subscription и models (того же пакета)
  - `subscription/` - подпакет для работы с подписками
    - `source_loader` координирует работу fetcher, node_parser, decoder
    - `fetcher` использует decoder и network utilities из core
    - `decoder` и `node_parser` - независимые утилиты
- `core/config_service.go` - тонкий слой, использует updater
- `core/controller.go`, `core/process_service.go` - используют `config/config_loader`

**Важно:** Циклических зависимостей нет. Все зависимости идут в одном направлении от низкоуровневых утилит к высокоуровневым сервисам.

---

## Примечания

- Сохранять обратную совместимость публичного API
- Все экспортируемые типы из `config/models` остаются доступны через `core/config.*`
- Изменения только в организации кода, функциональность не меняется
- Следовать принципам из `todo/IMPLEMENTATION_PROMPT.md`

