# Концепция системы статистики (Telemetry)

## Цель

Собрать минимально достаточный и безопасный набор данных, который даст ответы на ключевые вопросы:
- Сколько активных пользователей (DAU/WAU/MAU)
- Кто обновился до новой версии
- Как часто запускают приложение
- Какие платформы и версии используются
- Где возникают проблемы (топ ошибок)

При этом система должна быть прозрачной, безопасной и не превращаться в "шпионаж".

---

## Принципы сбора данных

### 1. Минимизация данных
Собираем только то, что необходимо для принятия решений о развитии продукта. Каждое поле должно иметь четкое обоснование.

### 2. Прозрачность
Пользователь должен понимать, что собирается и зачем. Opt-in подход (по умолчанию выключено) или как минимум явное уведомление.

### 3. Анонимность
Никаких данных, которые могут идентифицировать конкретного пользователя или устройство:
- ❌ IP-адреса
- ❌ MAC-адреса, серийные номера
- ❌ Содержимое конфигов, домены, UUID аккаунтов
- ❌ Имена Wi-Fi сетей, геолокация
- ❌ Список установленных приложений

### 4. Allowlist подход
Собираем только явно разрешенные типы данных. Все остальное — запрещено по умолчанию.

### 5. Локальное хранение идентификаторов
`client_id` генерируется и хранится только локально, никогда не привязывается к железу.

---

## Структура событий

### Базовые события (обязательные)

#### `first_launch`
**Когда:** Первый запуск приложения на данном устройстве  
**Частота:** Один раз за всё время  
**Поля:**
- `event: "first_launch"`
- `ts` (timestamp)
- `client_id`
- `app_version`, `os`, `arch`

**Цель:** Подсчет новых установок, понимание притока пользователей

---

#### `launch`
**Когда:** Каждый запуск приложения  
**Частота:** При каждом старте  
**Поля:**
- `event: "launch"`
- `ts`
- `client_id`
- `session_id` (UUID для этого запуска)
- `app_version`, `os`, `arch`
- `prev_session_end_ts` (опционально, если был предыдущий сеанс)

**Цель:** 
- DAU/WAU/MAU метрики
- Частота использования
- Retention (возвращаемость пользователей)

---

### Опциональные события

#### `session_end`
**Когда:** Закрытие приложения (graceful shutdown)  
**Частота:** При каждом закрытии  
**Поля:**
- `event: "session_end"`
- `ts`
- `client_id`
- `session_id` (соответствует launch)
- `session_duration_ms` (длительность сессии)

**Цель:** 
- Средняя длительность сессии
- Понимание паттернов использования

**Примечание:** Если приложение закрывается через kill/системный shutdown, событие может не отправиться. Это нормально — считаем по `launch` событиям.

---

#### `error`
**Когда:** Критическая или частая ошибка  
**Частота:** При возникновении ошибки (с rate limiting)  
**Поля (базовая allowlist):**
- `event: "error"`
- `ts`
- `client_id`
- `error_code` (например: `E_OPENGL_UNAVAILABLE`, `E_TUN_PERMISSION`, `E_CONFIG_PARSE`)
- `app_version`, `os`, `arch`

**Поля (опциональные расширения, если добавлены в allowlist relay):**
- `error_area` (`ui`, `core`, `network`, `fs`, `config`)
- `os_version` (мажорная.минорная версия ОС)
- `context` (высокоуровневый: `startup`, `config_load`, `proxy_start`)

**Цель:**
- Топ проблемных мест
- Корреляция ошибок с версиями/платформами
- Приоритизация исправлений

**Важно:** 
- Только коды ошибок из allowlist
- Никаких текстов ошибок, путей, доменов, IP
- Rate limiting: не более N ошибок одного типа в час

---

#### `feature_used`
**Когда:** Использование ключевой функции  
**Частота:** При каждом использовании (с возможным дедупликацией)  
**Поля:**
- `event: "feature_used"`
- `ts`
- `client_id`
- `feature` (например: `start_tun`, `start_proxy`, `wizard_completed`, `subscription_updated`)
- `result` (`ok` / `fail`)
- `error_code` (если `result: "fail"`)

**Цель:**
- Какие функции популярны
- Где пользователи сталкиваются с проблемами
- Приоритизация развития функций

**Список рекомендуемых фич:**
- `start_proxy` / `stop_proxy`
- `start_tun` / `stop_tun`
- `wizard_completed` (завершение мастера настройки)
- `subscription_updated` (обновление подписки)

---

## Идентификаторы

### `client_id` (обязательно)
**Тип:** UUIDv4  
**Генерация:** Один раз при первом запуске, хранится локально  
**Хранение:** Локальный файл в папке `/bin` (например, `bin/telemetry.json`)  
**Важно:**
- ❌ Не привязывать к железу (MAC, serial, IMEI)
- ❌ Не хэшировать hardware fingerprint
- ❌ Не использовать системные идентификаторы
- ✅ Просто случайный UUID, который хранится локально

**Цель:** 
- Подсчет уникальных пользователей
- Retention метрики

---

### `session_id` (опционально, но рекомендуется)
**Тип:** UUIDv4 или timestamp-based ID  
**Генерация:** При каждом `launch`  
**Хранение:** В памяти, не сохраняется между запусками  
**Цель:** Связывание событий в рамках одной сессии

---

## Метаданные окружения

### Обязательные поля

#### `app_version`
**Формат:** Semantic versioning (например: `0.8.0`)  
**Источник:** Из билда приложения

#### `os`
**Значения:** `windows`, `darwin`, `linux`  
**Источник:** Определяется во время компиляции или runtime

#### `arch`
**Значения:** `amd64`, `arm64`, `386` и т.д.  
**Источник:** Определяется во время компиляции или runtime

---

### Опциональные поля

#### `os_version`
**Формат:** Мажорная.минорная версия (например: `10`, `11`, `14.2`)  
**Важно:** Без точной модели устройства, без build number  
**Цель:** Понимание проблем на конкретных версиях ОС

#### `channel`
**Значения:** `stable`, `beta`, `dev`  
**Цель:** Разделение метрик по каналам обновлений

---

## Сессии и частота запусков

### Подход 1: Простой (рекомендуется для MVP)
Считать частоту только по событиям `launch`:
- За сутки: сколько уникальных `client_id` отправили `launch` за последние 24 часа
- За неделю/месяц: аналогично

**Преимущества:** Простота, не требует `session_end`

---

### Подход 2: С сессиями
Если есть `session_end`:
- `session_duration_ms` — длительность сессии
- Можно считать среднюю длительность, медиану
- Можно определять "активные" сессии (дольше N минут)

**Недостатки:** Событие может не отправиться при краше/kill

---

### Подход 3: Heartbeat (рекомендуется)
Периодическая отправка накопленных событий во время работы приложения.  
**Интервал:** 1 раз в час  
**Преимущества:**
- Регулярная отправка накопленных событий
- Не блокирует работу приложения
- Пользователь видит, что отправляется (события накапливаются локально)

**Реализация:**
- События накапливаются локально в файле
- Раз в час отправляется батч накопленных событий
- Пользователь может просмотреть локально сохранённые события перед отправкой

**Рекомендация:** Использовать подход 3 (heartbeat раз в час) в сочетании с локальным накоплением событий.

---

## Использование функций (Feature Usage)

### Принцип
Собираем только высокоуровневые действия, без деталей реализации.

### Формат события
```json
{
  "event": "feature_used",
  "ts": 1234567890,
  "client_id": "uuid-here",
  "feature": "start_tun",
  "result": "ok"
}
```

Или при ошибке:
```json
{
  "event": "feature_used",
  "ts": 1234567890,
  "client_id": "uuid-here",
  "feature": "start_tun",
  "result": "fail",
  "error_code": "E_CONFIG_PARSE"
}
```

### Список рекомендуемых функций
- `start_proxy` — запуск прокси
- `stop_proxy` — остановка прокси
- `start_tun` — запуск TUN интерфейса
- `stop_tun` — остановка TUN интерфейса
- `open_logs` — открытие логов
- `wizard_completed` — завершение мастера настройки
- `subscription_updated` — обновление подписки

---

## Ошибки (строгий allowlist)

### Принцип
Только коды ошибок из предопределенного списка. Никаких свободных текстов.

### Структура события (базовая allowlist)
```json
{
  "event": "error",
  "ts": 1739550000,
  "client_id": "550e8400-e29b-41d4-a716-446655440000",
  "error_code": "E_TUN_PERMISSION",
  "app_version": "0.8.0",
  "os": "darwin",
  "arch": "arm64"
}
```

**Примечание:** Поля `error_area`, `os_version`, `context` не входят в базовую allowlist схему, но могут быть добавлены в relay при необходимости.

### Примеры кодов ошибок
- `E_OPENGL_UNAVAILABLE` — OpenGL недоступен
- `E_TUN_PERMISSION` — нет прав на создание TUN интерфейса
- `E_CONFIG_PARSE` — ошибка парсинга конфига
- `E_CONFIG_VALIDATE` — ошибка валидации конфига
- `E_NETWORK_TIMEOUT` — таймаут сети
- `E_CORE_START_FAILED` — не удалось запустить ядро
- `E_CORE_CRASH` — краш ядра
- `E_UPDATE_FAILED` — ошибка обновления
- `E_SUBSCRIPTION_FETCH_FAILED` — ошибка загрузки подписки

### Rate limiting
Не более N ошибок одного типа от одного `client_id` в час (например, 10). Это предотвращает спам при зацикливании ошибки.

---

## Что НЕ собирать (жёсткий запрет)

### Идентификаторы устройств
- ❌ MAC-адреса
- ❌ Серийные номера
- ❌ IMEI
- ❌ Hardware UUID
- ❌ Любые уникальные идентификаторы железа

### Сетевая информация
- ❌ IP-адреса (и не хранить их на сервере в логах)
- ❌ Домены из конфигов
- ❌ UUID аккаунтов/прокси
- ❌ Имена Wi-Fi сетей
- ❌ DNS серверы

### Конфигурация и данные
- ❌ Содержимое конфигов (даже частичное)
- ❌ Список правил (rules)
- ❌ Названия профилей
- ❌ Параметры прокси (серверы, порты, пароли)

### Системная информация
- ❌ Список установленных приложений
- ❌ Запущенные процессы
- ❌ Имена пользователей системы
- ❌ Пути к файлам (кроме общих паттернов типа "config в стандартной директории")

### Геолокация
- ❌ Точные координаты
- ❌ Город/страна (даже если можно определить по IP — не делаем)

### Произвольные тексты
- ❌ Тексты ошибок (только коды)
- ❌ Логи (даже частичные)
- ❌ Пользовательский ввод

---

## Итоговый набор полей (allowlist)

### Единая схема allowlist (реализация)

Relay пропускает только следующие поля. Все остальные поля отбрасываются автоматически.

#### Обязательные поля (для всех событий)
- `event` — тип события: `launch`, `first_launch`, `error`, `feature_used`
- `ts` — unix timestamp (UTC)
- `client_id` — UUIDv4

#### Опциональные поля (в зависимости от события)
- `session_id` — UUIDv4 (для связывания событий в сессии)
- `app_version` — версия приложения (например: `0.8.0`)
- `os` — операционная система: `windows`, `darwin`, `linux`
- `arch` — архитектура: `amd64`, `arm64`
- `os_version` — версия ОС (мажорная.минорная, например: `14.2`)
- `channel` — канал обновлений: `stable`, `beta`, `dev`
- `feature` — используемая функция (только для события `feature_used`):
  - `start_tun`, `start_proxy`, `wizard_completed`, `subscription_updated`
- `result` — результат операции (только для события `feature_used`): `ok`, `fail`
- `error_code` — код ошибки (для событий `error` и `feature_used` с `result: fail`):
  - `E_TUN_PERMISSION`, `E_OPENGL_UNAVAILABLE`, `E_CONFIG_PARSE`

### Важно
- Все поля, не входящие в этот список, **автоматически отбрасываются** на уровне relay
- Даже если клиент случайно отправит запрещённое поле (например, `ip_address`, `config_content`), оно не пройдёт через relay
- Это обеспечивает двойную защиту: на клиенте стараемся не отправлять лишнее, на relay гарантированно фильтруем

---

## Метрики, которые можно получить

### Активность пользователей
- **DAU** (Daily Active Users) — уникальные `client_id` с событием `launch` за сутки
- **WAU** (Weekly Active Users) — за неделю
- **MAU** (Monthly Active Users) — за месяц
- **Retention** — процент пользователей, вернувшихся через N дней

### Распределение
- Распределение по версиям (`app_version`)
- Распределение по ОС (`os`, `os_version`)
- Распределение по архитектурам (`arch`)
- Распределение по каналам (`channel`)

### Обновления
- Доля пользователей, обновившихся до новой версии
- Время распространения обновления (сколько дней до 50%/90% пользователей)
- Какие версии популярны (старые vs новые)

### Частота использования
- Среднее количество запусков на пользователя в день/неделю
- Медианная длительность сессии (если есть `session_end`)
- Паттерны использования (утро/день/вечер, будни/выходные)

### Проблемы
- Топ ошибок по `error_code`
- Корреляция ошибок с версиями/ОС/архитектурами
- Частота ошибок по `error_area` (ui, core, network, etc.)

### Использование функций
- Популярность функций (топ по `feature`)
- Процент успешных использований (`result: ok` vs `fail`)
- Проблемные функции (высокий процент `fail`)

---

## Оптимизация и производительность

### Локальное накопление событий (основной подход)

**Ключевая идея:** Статистика копится локально, а только по возможности и разрешению уходит на сервер.

#### Принцип работы
1. **Все события сохраняются локально** в файл (например, `bin/telemetry-events.jsonl`)
2. **Пользователь может просмотреть** все накопленные события перед отправкой
3. **Отправка происходит периодически** (раз в 12 часов) или по запросу пользователя
4. **При отправке** события батчами уходят на сервер
5. **После успешной отправки** события помечаются как отправленные или удаляются

#### Преимущества
- ✅ Пользователь видит, что именно отправляется
- ✅ Нет избыточного трафика (не отправляем каждое событие отдельно)
- ✅ Работает офлайн (события накапливаются, отправятся когда будет интернет)
- ✅ Прозрачность — пользователь может проверить данные
- ✅ Контроль — пользователь может решить, отправлять или нет

#### Формат локального хранения
```jsonl
{"event":"launch","ts":1739550000,"client_id":"...","app_version":"0.8.0","os":"darwin","arch":"arm64","sent":false}
{"event":"feature_used","ts":1739551000,"client_id":"...","feature":"start_tun","result":"ok","sent":false}
```

### Батчинг и heartbeat

#### Heartbeat раз в 12 часов
- Каждые 12 часов отправляется батч всех неотправленных событий
- Это предотвращает избыточный трафик от частых heartbeat
- Пользователь видит накопленные события и может проверить их перед отправкой

#### Батчинг событий
- При отправке события группируются в батчи (например, до 100 событий в одном запросе)
- Это уменьшает количество HTTP-запросов
- Ускоряет обработку на сервере

#### При закрытии приложения
- Опционально: отправить все накопленные события при graceful shutdown
- Или оставить для следующего heartbeat (раз в 12 часов)

### Retry и backoff
- При ошибке сети — события остаются локально (не удаляются)
- Повторять отправку при следующем heartbeat с экспоненциальным backoff
- Не блокировать работу приложения на отправку статистики

### Асинхронность
- Отправка статистики не должна блокировать UI или основную логику
- Использовать отдельную горутину/воркер
- Heartbeat работает в фоне

### Управление размером хранилища
- Ограничить размер файла (например, не более 10,000 событий)
- При достижении лимита:
  - Удалять старые отправленные события
  - Или ротировать файл (архивировать старые события)
- Предупреждать пользователя, если накопилось много неотправленных событий

---

## Безопасность и приватность

### Шифрование передачи
- Использовать HTTPS для отправки событий
- Проверять сертификат сервера

### Локальное хранение
- `client_id` и события хранить в папке `/bin`:
  - `bin/telemetry.json` — метаданные (`client_id`, настройки)
  - `bin/telemetry-events.jsonl` — накопленные события (JSONL формат)
- Пользователь может просмотреть файлы и проверить, что отправляется
- Не хранить в открытом виде чувствительные данные (их и так нет благодаря allowlist)

### Opt-in / Opt-out
- По умолчанию статистика **выключена** (рекомендуется)
- При первом запуске показать диалог с объяснением, что собирается
- Пользователь может включить/выключить в настройках
- При выключении — не отправлять события, но можно продолжать собирать локально (для будущего включения)

### Прозрачность
- В настройках показать, что именно собирается
- Возможность просмотра локально сохраненных событий (для отладки)
- Документация в README о том, что собирается

---

## Архитектурные соображения

### Модульность
- Отдельный пакет для telemetry (например, `internal/telemetry`)
- Четкое разделение: сбор событий, локальное хранение, отправка

### Тестируемость
- Возможность мокирования отправки для тестов
- Локальное тестирование без реального сервера

### Расширяемость
- Легко добавлять новые типы событий
- Легко добавлять новые поля (с учетом allowlist)

### Выключатель
- Возможность полностью отключить telemetry через:
  - Переменную окружения (например, `SINGBOX_TELEMETRY=off`)
  - Флаг компиляции (для сборок без telemetry)
  - Настройки приложения

---

## Архитектура системы

### Структура репозиториев

Система состоит из трёх независимых репозиториев:

#### A) Основной репозиторий
**`Leadaxe/singbox-launcher`**

**Содержит:**
- Клиентскую отправку telemetry (opt-in)
- `PRIVACY.md` с описанием схемы событий и политики приватности
- Код приложения с интеграцией telemetry

**Ответственность:**
- Генерация событий
- Локальное хранение `client_id` и `prev_version`
- Отправка событий на relay endpoint
- Opt-in/opt-out управление

---

#### B) Репозиторий телеметрии и дашборда
**`Leadaxe/singbox-launcher-telemetry`**

**Содержит:**
- GitHub Action, который принимает события через `repository_dispatch`
- Хранение данных (агрегаты + опционально сырые события)
- Генерацию `stats.json` и `stats.md`
- GitHub Pages (опционально) для красивого публичного отчёта

**Ответственность:**
- Приём событий от relay
- Агрегация данных
- Генерация статистики
- Публикация отчётов

---

#### C) Relay (Cloudflare Worker)
**`Leadaxe/singbox-launcher-telemetry-relay`**

**Содержит:**
- Код воркера для Cloudflare Workers
- Инструкции по деплою
- Конфигурацию allowlist полей, лимитов, подписи (опционально)

**Ответственность:**
- Валидация входящих событий
- Применение allowlist (фильтрация полей)
- Rate limiting / anti-spam защита
- Опциональная HMAC подпись/проверка
- Диспетчеризация событий в GitHub через `repository_dispatch`

---

### Поток данных

```
┌─────────────────┐
│   Launcher      │
│  (клиент)       │
└────────┬────────┘
         │
         │ POST https://telemetry.leadaxe.dev/e
         │
         ▼
┌─────────────────────────────┐
│  Cloudflare Worker (relay) │
│  - валидация + allowlist   │
│  - rate-limit / anti-spam  │
│  - (опционально) HMAC       │
└────────┬────────────────────┘
         │
         │ dispatch → GitHub
         │
         ▼
┌─────────────────────────────┐
│  GitHub repository_dispatch │
│  (telemetry repo)           │
└────────┬────────────────────┘
         │
         ▼
┌─────────────────────────────┐
│  GitHub Action              │
│  - append event (опц.)      │
│  - update aggregates        │
│  - write stats.json/md      │
└─────────────────────────────┘
```

---

### Схема события (единая allowlist)

Relay пропускает только следующие поля (всё остальное отбрасывается):

```json
{
  "event": "launch|first_launch|error|feature_used",
  "ts": 1739550000,
  "client_id": "uuid-v4",
  "session_id": "uuid-v4",
  "app_version": "0.8.0",
  "os": "windows|darwin|linux",
  "arch": "amd64|arm64",
  "os_version": "14.2",
  "channel": "stable|beta|dev",
  "feature": "start_tun|start_proxy|wizard_completed|subscription_updated",
  "result": "ok|fail",
  "error_code": "E_TUN_PERMISSION|E_OPENGL_UNAVAILABLE|E_CONFIG_PARSE"
}
```

**Ключевая идея:** Никаких конфигов, доменов, IP, путей, текстов ошибок. Только явно разрешённые поля из allowlist.

---

### Cloudflare Worker (Relay)

#### Endpoint
- **Route:** `POST /e`
- **URL:** `https://telemetry.leadaxe.dev/e`

#### Environment Secrets
- `GITHUB_TOKEN` — Personal Access Token (PAT) с правами только на telemetry repo
- `GITHUB_OWNER` — `Leadaxe`
- `GITHUB_REPO` — `singbox-launcher-telemetry`

#### Обязательная функциональность Worker

1. **JSON Parse**
   - Парсинг входящего JSON
   - Валидация структуры

2. **Allowlist полей**
   - Фильтрация: оставить только разрешённые поля
   - Отбросить все остальные поля (даже если они присутствуют)

3. **Валидация**
   - Проверка обязательных полей (`event`, `ts`, `client_id`)
   - Проверка типов и форматов (UUID, timestamp, enum значения)
   - Валидация значений enum полей (`event`, `os`, `arch`, `result`, etc.)

4. **Rate Limiting**
   - Минимум: 1 событие / 10 секунд на `client_id`
   - Hard cap: N событий/минуту на IP (защита от спама Actions)
   - Использовать Cloudflare KV или Durable Object (воркеры stateless, in-memory не подходит)

5. **Dispatch в GitHub**
   - `POST https://api.github.com/repos/{owner}/{repo}/dispatches`
   - Тип события: `telemetry`
   - Payload: отфильтрованное и валидированное событие

#### Опциональная функциональность

- **HMAC подпись/проверка** — для дополнительной защиты от подделки событий
- **Логирование** — минимальное логирование для отладки (без чувствительных данных)

---

### GitHub Action в telemetry repo

#### Trigger
```yaml
on:
  repository_dispatch:
    types: [telemetry]

permissions:
  contents: write
```

#### Функциональность Action

1. **Приём события**
   - Получить событие из `repository_dispatch`
   - Валидировать структуру

2. **Хранение (опционально)**
   - Append сырого события в файл (например, `events/YYYY-MM-DD.jsonl`)
   - Или пропустить, если храним только агрегаты

3. **Обновление агрегатов**
   - Обновить счётчики в памяти/файле
   - Агрегировать по:
     - Типу события
     - Версии приложения
     - ОС и архитектуре
     - Кодам ошибок
     - Используемым функциям

4. **Генерация статистики**
   - `stats.json` — машинно-читаемый формат
   - `stats.md` — человеко-читаемый отчёт
   - Обновить файлы в репозитории

5. **Публикация (опционально)**
   - Если используется GitHub Pages — обновить публичный дашборд

---

### Преимущества архитектуры

1. **Разделение ответственности**
   - Клиент только отправляет
   - Relay валидирует и защищает
   - Telemetry repo хранит и агрегирует

2. **Безопасность**
   - Allowlist на уровне relay (двойная защита)
   - Rate limiting защищает от спама
   - GitHub Actions изолированы от прямого доступа клиентов

3. **Масштабируемость**
   - Cloudflare Workers масштабируются автоматически
   - GitHub Actions обрабатывают события асинхронно
   - Можно добавить очередь при необходимости

4. **Прозрачность и инспекция**
   - Код relay открыт — любой может проверить логику фильтрации
   - Код Action открыт — видно, как обрабатываются события
   - Пользователи могут проверить, что именно собирается
   - История изменений в Git — полная аудиторская тропа
   - Возможность просмотра сырых событий (если хранятся) и агрегатов
   - Публичный дашборд на GitHub Pages — безопасная публикация статистики

5. **Простота**
   - Не нужен отдельный сервер
   - Используем GitHub как хранилище и обработчик
   - Минимум инфраструктуры

---

## Прозрачность и безопасная публикация статистики

GitHub архитектура обеспечивает уникальную возможность безопасно показывать статистику, позволяя инспектировать работу приложения и системы статистики.

### Открытость кода

#### Relay (Cloudflare Worker)
- **Публичный репозиторий** `singbox-launcher-telemetry-relay`
- Любой может проверить:
  - Какие поля разрешены (allowlist)
  - Логику валидации
  - Rate limiting правила
  - Как происходит фильтрация данных

#### GitHub Action
- **Публичный репозиторий** `singbox-launcher-telemetry`
- Любой может проверить:
  - Как обрабатываются события
  - Как формируются агрегаты
  - Какие метрики вычисляются
  - Логику генерации отчётов

#### Клиентский код
- **Публичный репозиторий** `singbox-launcher`
- Любой может проверить:
  - Какие события отправляются
  - Когда и как часто
  - Что хранится локально

### Инспекция данных

#### Просмотр событий
Если сырые события хранятся в репозитории:
- Файлы событий доступны для просмотра (например, `events/2026-02-15.jsonl`)
- Можно проверить реальные данные, которые собираются
- История изменений через Git — видно, как данные накапливаются

#### Просмотр агрегатов
- Файл `stats.json` — машинно-читаемый формат
- Файл `stats.md` — человеко-читаемый отчёт
- История изменений показывает динамику метрик

#### Аудит системы
- Git commit history — полная история всех изменений
- GitHub Actions logs — можно проверить, как обрабатывались события
- Issues и PRs — обсуждение изменений в системе статистики

### Безопасная публикация статистики

#### GitHub Pages дашборд
- **Публичный URL** (например, `https://leadaxe.github.io/singbox-launcher-telemetry/`)
- Автоматическое обновление при каждом новом событии
- Безопасно, потому что:
  - Показываются только агрегированные данные
  - Нет персональных данных (только `client_id` — анонимный UUID)
  - Нет чувствительной информации (IP, домены, конфиги)
  - Данные проходят двойную фильтрацию (клиент + relay)

#### Что можно показывать публично
- ✅ Общее количество активных пользователей (DAU/WAU/MAU)
- ✅ Распределение по версиям приложения
- ✅ Распределение по ОС и архитектурам
- ✅ Топ ошибок (только коды, без деталей)
- ✅ Популярность функций
- ✅ Статистика обновлений
- ✅ Графики и тренды

#### Что нельзя показывать
- ❌ Сырые события с полными данными (если хранятся — только в приватном репозитории)
- ❌ Связки `client_id` с другими данными, которые могут идентифицировать пользователя
- ❌ Любые данные, которые могут быть использованы для деанонимизации

### Преимущества для пользователей

1. **Доверие**
   - Пользователи видят, что собирается и как обрабатывается
   - Открытый код — нет "чёрного ящика"
   - Можно проверить соответствие заявленному

2. **Проверка приватности**
   - Пользователи могут убедиться, что не собираются чувствительные данные
   - Видно, что allowlist действительно фильтрует лишнее
   - Публичная статистика подтверждает отсутствие персональных данных

3. **Польза для сообщества**
   - Пользователи видят статистику использования
   - Понимают, какие версии популярны
   - Видят топ проблем и могут помочь с исправлениями

### Преимущества для разработчиков

1. **Отладка системы**
   - Можно проверить, правильно ли работает relay
   - Видно, как обрабатываются события в Action
   - Легко найти проблемы в логике агрегации

2. **Мониторинг**
   - GitHub Actions logs показывают обработку событий
   - Можно отследить ошибки в системе статистики
   - Видно производительность обработки

3. **Развитие**
   - Сообщество может предложить улучшения
   - Прозрачность способствует доверию
   - Легко добавить новые метрики

### Примеры инспекции

#### Проверка allowlist
```bash
# Пользователь может проверить код relay
git clone https://github.com/Leadaxe/singbox-launcher-telemetry-relay
# Увидеть список разрешённых полей
cat src/index.js | grep allowlist
```

#### Просмотр статистики
```bash
# Просмотр публичной статистики
curl https://leadaxe.github.io/singbox-launcher-telemetry/stats.json
# Или открыть в браузере
open https://leadaxe.github.io/singbox-launcher-telemetry/
```

#### Проверка обработки событий
```bash
# Просмотр GitHub Actions logs
# В репозитории telemetry можно увидеть, как обрабатывались события
```

---

## Вопросы для уточнения

1. **Opt-in или opt-out?** Рекомендуется opt-in (по умолчанию выключено).
2. **Хранение сырых событий?** Хранить ли сырые события или только агрегаты? Рекомендуется: агрегаты обязательно, сырые опционально (для отладки, с автоматическим удалением через N дней).
3. **Rate limiting параметры?** Конкретные значения для rate limits (1/10 сек на client_id, N/мин на IP).
4. **HMAC подпись?** Нужна ли дополнительная защита через HMAC подпись событий?
5. **GitHub Pages дашборд?** Нужен ли публичный дашборд на GitHub Pages?
6. **Retention сырых событий?** Если храним сырые события, как долго (например, 30 дней)?

---

## Рекомендации по реализации (концептуально)

### Этап 1: MVP
1. Базовые события: `first_launch`, `launch`
2. Минимальный набор полей
3. Локальное накопление событий в `bin/telemetry-events.jsonl`
4. Heartbeat раз в 12 часов для отправки накопленных событий
5. Opt-in с диалогом при первом запуске
6. Возможность просмотра локально накопленных событий

### Этап 2: Расширение
1. Добавить `error` и `feature_used` события
2. Батчинг и асинхронная отправка
3. Локальное хранилище неотправленных событий
4. Расширенный набор полей

### Этап 3: Оптимизация
1. `session_end` для подсчета длительности сессий
2. Rate limiting для ошибок
3. Улучшенный retry с backoff
4. Мониторинг и алерты на сервере

---

## Итоговая схема событий (единая allowlist)

Все события должны соответствовать единой схеме allowlist. Relay автоматически отфильтрует любые поля, не входящие в список.

### Событие `first_launch`
```json
{
  "event": "first_launch",
  "ts": 1739550000,
  "client_id": "550e8400-e29b-41d4-a716-446655440000",
  "app_version": "0.8.0",
  "os": "darwin",
  "arch": "arm64"
}
```

### Событие `launch`
```json
{
  "event": "launch",
  "ts": 1739550000,
  "client_id": "550e8400-e29b-41d4-a716-446655440000",
  "session_id": "660e8400-e29b-41d4-a716-446655440001",
  "app_version": "0.8.0",
  "os": "darwin",
  "arch": "arm64"
}
```

### Событие `error`
```json
{
  "event": "error",
  "ts": 1739550000,
  "client_id": "550e8400-e29b-41d4-a716-446655440000",
  "error_code": "E_TUN_PERMISSION",
  "app_version": "0.8.0",
  "os": "darwin",
  "arch": "arm64"
}
```

**Примечание:** В базовой allowlist схеме нет полей `error_area` и `context`. Если они нужны, их нужно добавить в allowlist relay.

### Событие `feature_used` (успех)
```json
{
  "event": "feature_used",
  "ts": 1739550000,
  "client_id": "550e8400-e29b-41d4-a716-446655440000",
  "feature": "start_tun",
  "result": "ok",
  "app_version": "0.8.0",
  "os": "darwin",
  "arch": "arm64"
}
```

### Событие `feature_used` (ошибка)
```json
{
  "event": "feature_used",
  "ts": 1739550000,
  "client_id": "550e8400-e29b-41d4-a716-446655440000",
  "feature": "start_tun",
  "result": "fail",
  "error_code": "E_CONFIG_PARSE",
  "app_version": "0.8.0",
  "os": "darwin",
  "arch": "arm64"
}
```

---

## Дополнительные идеи

### 1. Агрегация на клиенте
Для экономии трафика можно агрегировать некоторые события на клиенте:
- Вместо 100 событий `launch` за день — одно событие `daily_summary` с количеством запусков
- Но это усложняет реализацию и может скрыть важные паттерны

**Рекомендация:** Начать с отправки отдельных событий, при необходимости добавить агрегацию позже.

### 2. Версионирование схемы событий
Добавить поле `schema_version` для обратной совместимости при изменении структуры событий.

### 3. Санитизация данных
Перед отправкой проверять, что в событиях нет запрещенных данных (например, случайно попавших путей или IP).

### 4. Логирование для отладки
В режиме отладки логировать события перед отправкой (для разработчиков), но не в production.

### 5. Метрики производительности
Опционально собирать метрики производительности (время запуска, время загрузки конфига), но это требует осторожности, чтобы не собирать чувствительные данные.

---

## Заключение

Предложенная концепция обеспечивает баланс между:
- **Полезностью данных** для принятия решений о развитии продукта
- **Безопасностью и приватностью** пользователей
- **Простотой реализации** и поддержки
- **Прозрачностью** для пользователей

Ключевые принципы:
1. Минимум данных, максимум пользы
2. Allowlist подход (только разрешенное)
3. Анонимность (никаких идентификаторов устройств)
4. Opt-in (по умолчанию выключено)
5. Прозрачность (пользователь знает, что собирается)

