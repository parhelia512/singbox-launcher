# Универсальный промпт для реализации задач

Реализуй задачу согласно техническому заданию. Следуй следующим принципам разработки.

## Контракт выхода (что должен вернуть Cursor)

После завершения реализации предоставь:

1. **Краткий план изменений** (1-3 пункта) - что было сделано
2. **Список изменённых файлов** - полные пути
3. **Ключевые фрагменты кода** (с путями) - только существенные изменения, не весь код
4. **Команды для проверки**:
   - `go build ./...` - компиляция
   - `go test ./...` - тесты
   - `go vet ./...` - статический анализ
   - линтер проекта (если есть)
5. **Риски и ограничения** - если есть, перечисли и как проверить
6. **Assumptions** (предположения) - если пришлось делать предположения из-за неполного ТЗ

**Формат ответа:**
- Пиши в Markdown
- Не пересказывай требования целиком
- Не вставляй огромные простыни кода - только ключевые фрагменты + ссылки на файлы
- Будь конкретным и кратким

## Требования к качеству кода

### 1. Структурированный и читаемый код
- Разбивай логику на небольшие, четко определенные функции с единственной ответственностью
- Используй понятные имена переменных и функций, отражающие их назначение
- Следуй существующему стилю кода в проекте (проверь другие файлы)
- Группируй связанную логику вместе
- Избегай чрезмерной вложенности - используй ранние возвраты (early returns)

### 2. Оптимизация
- Избегай повторных вызовов системных команд или дорогих операций - кэшируй результаты где возможно
- Не создавай лишние промежуточные переменные без необходимости
- Используй эффективные алгоритмы и структуры данных
- Минимизируй количество системных вызовов и операций ввода-вывода
- Избегай преждевременной оптимизации - сначала сделай код читаемым и корректным

### 3. Чистота кода и избежание избыточности
- **НЕ** делай избыточных проверок - если значение уже проверено, не проверяй его снова
- Не вводи лишние переменные, но используй их, если они улучшают читаемость или убирают дублирование
- Удаляй закомментированный код перед завершением задачи
- Используй early returns для упрощения логики и уменьшения вложенности
- Избегай дублирования кода - выноси повторяющуюся логику в отдельные функции
- Удаляй неиспользуемый код и импорты

### 4. Комментирование
- Комментируй **почему**, а не **что** (код должен быть самодокументирующимся)
- Используй Go-стиль комментариев: `// FunctionName does something` перед функциями
- Добавь краткие комментарии для неочевидных участков кода
- В сложных местах поясняй бизнес-логику, ограничения или причины выбранного подхода
- Комментируй публичные API функции и структуры

### 5. Обработка ошибок
- Всегда обрабатывай ошибки явно - не игнорируй их без веской причины
- Оборачивай ошибки через `fmt.Errorf("context: %w", err)` для сохранения первопричины
- Добавляй контекст на каждом уровне обработки
- Если проект использует sentinel errors (`var ErrSomething = errors.New("...")`) или typed errors - следуй этому стилю
- Не теряй первопричину ошибки - используй `%w` вместо `%v`
- Логируй ошибки в соответствующих местах для отладки

### 6. Тестирование и надежность
- Если логика не тривиальная - добавь unit-тесты в соответствующий `*_test.go` файл
- Минимум покрытия тестами: happy path + 1-2 edge cases + ошибка/невалидный ввод
- Тесты должны быть детерминированными - избегай реального времени, сети, файловой системы
- Используй моки/фейки для внешних зависимостей
- Учитывай граничные случаи и крайние значения в коде
а- Обрабатывай ситуации, когда данные могут быть некорректными
- Проверяй, что изменения не ломают существующую функциональность
- Убедись, что код работает на всех поддерживаемых платформах (если применимо)

### 7. Валидация входных данных
- Всегда проверяй входные параметры функций на валидность
- Проверяй указатели на `nil` перед использованием
- Проверяй пустые строки и некорректные значения
- Проверяй существование файлов и директорий перед работой с ними (`os.Stat`, `os.Stat`)
- Возвращай понятные ошибки при невалидных входных данных

### 8. Константы и магические числа
- Используй константы вместо магических чисел и строк
- Проверяй существующие константы в `internal/constants` перед созданием новых
- Для повторно используемых значений (таймауты, размеры буферов, имена файлов) создавай константы
- Группируй связанные константы вместе в блоки `const`

### 9. Управление ресурсами
- Всегда используй `defer` для закрытия ресурсов (файлы, соединения, контексты)
- Закрывай ресурсы сразу после открытия: `defer file.Close()`, `defer conn.Close()`, `defer cancel()`
- Для множественных ресурсов используй `defer` для каждого
- Убедись, что все открытые ресурсы будут закрыты даже при ошибках

### 10. Таймауты и контексты
- Для сетевых операций используй таймауты из `core/network_utils` или создавай через `context.WithTimeout`
- Используй `context` для отмены долгих операций
- Передавай контекст в функции, которые поддерживают его
- Всегда вызывай `cancel()` функции, полученной из `context.WithTimeout`/`WithCancel` (через `defer`)

### 11. Порядок импортов
- Следуй стандартной Go группировке импортов:
  1. Стандартная библиотека (`fmt`, `os`, `net`, и т.д.)
  2. Сторонние библиотеки (`fyne.io/...`, `github.com/...`)
  3. Локальные пакеты (`singbox-launcher/...`)
- Используй пустые строки для разделения групп
- Форматируй импорты через `goimports` или вручную в алфавитном порядке внутри группы

### 12. Платформо-специфичный код
- Для кода, который работает только на определенной платформе, используй build tags:
  - `//go:build darwin` для macOS
  - `//go:build windows` для Windows
  - `//go:build linux` для Linux
- Платформо-специфичные функции размещай в соответствующих файлах `internal/platform/`
- Общую логику выноси в `platform_common.go` или общие пакеты

### 13. Использование существующих утилит
- Перед написанием новой функции проверь существующие утилиты:
  - `core/network_utils` - для сетевых операций и таймаутов
  - `internal/constants` - для констант
  - `internal/debuglog` - для логирования (централизованная система)
  - `internal/platform` - для платформо-специфичных операций
- Не дублируй функциональность - используй существующие функции
- Если нужна похожая функция, расширь существующую или создай общую утилиту

### 14. Минимальный дифф и контроль изменений
- **Не делай широких рефакторингов** и переименований без необходимости для ТЗ
- **Не меняй публичные API/форматы/CLI/конфиги**, если это не требуется ТЗ
- **Сохраняй обратную совместимость** по умолчанию
- Меняй только то, что нужно для выполнения задачи
- Если нужно нарушить совместимость - явно укажи это в выводе и обоснуй

### 15. Зависимости проекта
- **Не добавляй новые зависимости** без крайней необходимости
- Если добавил зависимость - объясни в выводе зачем и почему нельзя без неё
- Обнови `go.mod` и `go.sum` корректно
- Проверь лицензии новых зависимостей (минимум - совместимость с проектом)
- Предпочитай стандартную библиотеку Go внешним пакетам

### 16. Логирование
- **Используй централизованную систему логирования `internal/debuglog`** - не используй стандартный `log` пакет
- **Не логируй секреты/ключи/токены/PII** - никаких чувствительных данных в логах
- **Используй правильные функции для уровней:**
  - `debuglog.ErrorLog()` - для ошибок
  - `debuglog.WarnLog()` - для предупреждений
  - `debuglog.InfoLog()` - для информационных сообщений
  - `debuglog.DebugLog()` - для отладочных сообщений
- **Уровень логирования контролируется через переменную окружения `SINGBOX_DEBUG`:**
  - `error` - только ошибки
  - `warn` - предупреждения и ошибки (по умолчанию)
  - `info` - информация, предупреждения и ошибки
  - `debug` или `verbose` - все логи кроме trace
  - `trace` - все логи включая trace
  - `off` - отключить все логи
- **Для измерения времени выполнения:**
  ```go
  timing := debuglog.StartTiming("operationName")
  defer timing.EndWithDefer()
  ```
- **Для логирования больших текстовых фрагментов:**
  ```go
  debuglog.LogTextFragment("Module", debuglog.LevelVerbose, "Description", text, 500)
  ```
- Логируй только "события" и ошибки - не спамь избыточными сообщениями
- Не создавай новые функции логирования - используй существующие из `internal/debuglog`

### 17. Обработка неполного ТЗ
- Если не хватает данных в ТЗ, сначала попробуй вывести разумные предположения
- Явно пометь предположения как **Assumptions** в выводе и продолжай работу
- Вопросы задавай только если без ответа нельзя безопасно реализовать функциональность
- При принятии решений на основе предположений - документируй их в комментариях кода

## Порядок работы

1. **Изучи техническое задание** - убедись, что понятны все требования. Если ТЗ неполное - сформулируй Assumptions, останови выполнене, задай вопросы.
2. **Изучи существующий код** - посмотри похожие реализации и стиль проекта
3. **Спланируй реализацию** - определи необходимые функции и их взаимодействие, минимальный набор изменений
4. **Реализуй код** - следуя принципам выше, делай минимальный дифф
5. **Проверь** - выполни Definition of Done (см. ниже)

## Definition of Done (проверка перед завершением)

**Обязательные проверки:**
- [ ] `go build ./...` - компилируется без ошибок и предупреждений
- [ ] `go test ./...` - все тесты проходят
- [ ] `go vet ./...` - статический анализ проходит
- [ ] Линтер проекта (если есть) - проходит без ошибок
- [ ] Нет новых warning'ов в сборке

**Качество кода:**
- [ ] Нет избыточных проверок или переменных
- [ ] Логирование добавлено в ключевых местах (следуя правилам из раздела 16)
- [ ] Комментарии добавлены где необходимо (особенно для неочевидной логики)
- [ ] Соблюден существующий стиль кода проекта
- [ ] Обработаны граничные случаи и ошибки
- [ ] Удален неиспользуемый код и импорты

**Требования реализации:**
- [ ] Входные данные валидируются
- [ ] Использованы константы вместо магических чисел
- [ ] Все ресурсы корректно закрываются через `defer`
- [ ] Для сетевых операций установлены таймауты
- [ ] Импорты правильно сгруппированы и отсортированы
- [ ] Платформо-специфичный код использует build tags
- [ ] Проверено использование существующих утилит перед созданием новых

**Совместимость и изменения:**
- [ ] Код не ломает существующую функциональность
- [ ] Не сделаны самовольные рефакторинги
- [ ] Сохранена обратная совместимость (если не требуется иначе)
- [ ] Документация/README обновлены, если менялся UX/CLI/config
- [ ] Если добавлены зависимости - обоснованы и обновлены go.mod/go.sum

## Важные замечания

1. **Приоритет читаемости** - код должен быть понятным для других разработчиков
2. **Минимальный дифф** - меняй только то, что нужно для задачи, без самовольных улучшений
3. **Избегай преждевременной оптимизации** - сначала сделай код корректным и читаемым
4. **Не дублируй логику** - выноси общую функциональность в отдельные функции
5. **Используй существующие паттерны** - следуй архитектуре и стилю проекта
6. **Тестируй изменения** - убедись, что все работает как ожидается
7. **Проверяй существующие утилиты** - перед написанием новой функции изучи доступные пакеты
8. **Управляй ресурсами** - всегда используй `defer` для освобождения ресурсов
9. **Устанавливай таймауты** - для всех сетевых и долгих операций
10. **Безопасность логов** - никогда не логируй секреты и чувствительные данные
11. **Оборачивай ошибки** - используй `%w` для сохранения первопричины


## Работа с Git (ОГРАНИЧЕНИЯ)

- **НЕ выполняй никаких действий с Git без явного указания**
- **НЕ**:
  - создавать коммиты
  - делать `git commit`, `git push`, `git pull`
  - создавать или переключать ветки
  - делать `rebase`, `merge`, `cherry-pick`
  - менять историю (`reset`, `reflog`, `amend`)
  - править `.gitignore`
  - изменять hooks или git-config

- Любые Git-действия допустимы **только при прямом указании** в ТЗ  
  (например: *«создай коммит», «подготовь diff», «оформи PR»*).

- По умолчанию:
  - работа ведётся **локально**
  - изменения считаются **не закоммиченными**
  - результат — **предлагаемый diff**, а не действия в репозитории

- Если для выполнения задачи **необходимы изменения в Git**:
  - остановись
  - объясни **зачем**
  - задай вопрос
  - **не предпринимай действий самостоятельно**

## Работа с консолью

- Все команды выполняются в рабочей директории проекта автоматически
- используй платформо-специфичные команды 
- **НЕ добавляй** `cd /path/to/project` к каждой команде
- Если нужно проверить текущую директорию - используй `pwd` один раз
- Команды типа `git status`, `go build`, `go test` выполняются напрямую без `cd`