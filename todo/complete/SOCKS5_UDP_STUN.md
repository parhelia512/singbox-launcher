# TODO: Реализация STUN теста через системный SOCKS5 прокси на macOS

## Описание задачи

На macOS по различным причинам сложно поднять TUN, проще сделать системный прокси, в который и UDP трафик идет (UDP ASSOCIATE).
Текущая реализация STUN теста в `ui/diagnostics_tab.go` использует прямое UDP соединение (`net.Dial("udp", ...)`), которое не проходит через системный прокси на macOS. Необходимо модифицировать функцию `checkSTUN` для автоматического использования системного SOCKS5 прокси, если он настроен и включен.

## Контекст

- Sing-box работает в режиме `mixed` inbound (SOCKS5 на портах, например, 7890, HTTP на 7891)
- Системный прокси автоматически настраивается через `set_system_proxy: true` в конфигурации
- Для UDP трафика через SOCKS5 требуется реализация UDP ASSOCIATE команды
- Библиотека `github.com/txthinking/socks5` поддерживает полный SOCKS5, включая UDP ASSOCIATE на клиенте

## Цель

STUN тест должен автоматически использовать системный SOCKS5 прокси на macOS, если он настроен и включен, чтобы показать внешний IP адрес через прокси.

## Шаги реализации

### 1. Добавить зависимость

```bash
go get github.com/txthinking/socks5
```

### 2. Реализовать функцию получения настроек системного прокси (macOS)

**Файл:** `internal/platform/platform_darwin.go`

Добавить функцию:
```go
// GetSystemSOCKSProxy returns system SOCKS proxy settings if enabled
// Returns proxy host, port, and enabled status
func GetSystemSOCKSProxy() (host string, port int, enabled bool, err error)
```

**Логика:**
- Использовать `networksetup -listallnetworkservices` для получения списка сетевых интерфейсов
- Найти активный интерфейс (предпочтительно Wi-Fi или Ethernet)
- Использовать `networksetup -getsocksfirewallproxy <interface>` для получения настроек прокси
- Парсить вывод команды для извлечения:
  - `Enabled: Yes/No`
  - `Server: <host>`
  - `Port: <port>`
- Возвращать host, port, enabled, error

**Импорты:**
- Добавить `strings` для парсинга вывода команд

### 3. Модифицировать функцию checkSTUN

**Файл:** `ui/diagnostics_tab.go`

**Изменения:**
- Добавить импорты:
  - `context` - для контекста с таймаутом
  - `runtime` - для проверки платформы
  - `github.com/txthinking/socks5` - для работы с SOCKS5 клиентом

**Логика функции:**
1. Проверить, что мы на macOS (`runtime.GOOS == "darwin"`)
2. Получить настройки системного прокси через `platform.GetSystemSOCKSProxy()`
3. Если прокси включен и настройки валидны:
   - Создать SOCKS5 клиент с использованием `github.com/txthinking/socks5`
   - Установить UDP соединение через SOCKS5 с поддержкой UDP ASSOCIATE
   - Использовать это соединение для STUN запроса
4. Если прокси не настроен или ошибка:
   - Использовать прямое UDP соединение (текущее поведение)

**Детали реализации:**
- Использовать `socks5.Client` из библиотеки для создания клиента
- Метод для UDP через SOCKS5 должен использовать UDP ASSOCIATE
- Обернуть результат в `net.Conn` для совместимости с `pion/stun.NewClient()`
- Сохранить fallback на прямое соединение для надежности

### 4. Обновить отображение результата

**Файл:** `ui/diagnostics_tab.go`

В функции `CreateDiagnosticsTab`, при отображении результата STUN теста:
- Добавить информацию о том, использовался ли прокси
- Пример: `"Your External IP: %s\n(determined via [UDP]%s via SOCKS5 proxy)"` или `"(direct connection)"`

### 5. Тестирование

**Сценарии для проверки:**

1. **Прокси включен:**
   - Настроить системный SOCKS5 прокси через `networksetup`
   - Запустить STUN тест
   - Проверить, что результат показывает IP через прокси
   - Проверить логи на наличие сообщений об использовании прокси

2. **Прокси выключен:**
   - Отключить системный прокси
   - Запустить STUN тест
   - Проверить, что используется прямое соединение
   - Проверить, что результат корректен

3. **Ошибка получения настроек прокси:**
   - Симулировать ошибку (или запустить на Linux/Windows)
   - Проверить fallback на прямое соединение

4. **Ошибка подключения через прокси:**
   - Настроить неверный адрес прокси
   - Проверить fallback на прямое соединение

## Технические детали

### Библиотека txthinking/socks5

- Поддерживает полный SOCKS5 протокол
- Имеет клиентскую реализацию с UDP ASSOCIATE
- Документация: https://github.com/txthinking/socks5

### SOCKS5 UDP ASSOCIATE

Процесс:
1. Установить TCP соединение с SOCKS5 прокси
2. Отправить команду UDP ASSOCIATE (0x03)
3. Получить адрес и порт для UDP relay
4. Отправлять UDP пакеты на relay с специальным заголовком SOCKS5
5. Получать UDP пакеты от relay с SOCKS5 заголовком

### Совместимость с pion/stun

- `pion/stun.NewClient()` принимает `net.Conn`
- Необходимо обернуть результат SOCKS5 UDP соединения в `net.Conn`
- Проверить совместимость типов и интерфейсов

## Примечания

- Реализация должна быть безопасной: всегда иметь fallback на прямое соединение
- Логировать использование прокси для отладки
- Не ломать существующую функциональность на других платформах
- Проверить, что TCP соединение для UDP ASSOCIATE корректно закрывается

## Файлы для изменения

1. `internal/platform/platform_darwin.go` - добавить `GetSystemSOCKSProxy()`
2. `ui/diagnostics_tab.go` - модифицировать `checkSTUN()` и `CreateDiagnosticsTab()`
3. `go.mod` - добавить зависимость `github.com/txthinking/socks5`

## Связанные проблемы

- Discord и другие приложения нуждаются в UDP через прокси
- STUN тест должен показывать IP через прокси, а не прямой IP


## Уточнения реализации
- Логика fallback: если системный прокси включен, но подключение через него не удалось, использовать прямое соединение или показать ошибку?
показать ошибку прямое соединение не пробовать.
- Логирование: Нужно конечно логировать попытки использования прокси и результаты (успех/fallback).
- Достаточно проверить, что прокси включен в системных настройках, доступность не важна.
- приоритет по порядку: Использовать networksetup -listnetworkserviceorder для получения приоритета. Проверять интерфейсы в порядке приоритета. Вернуть первый интерфейс с включенным прокси